# The Sun Network Filesystem: Design, Implementation and Experience

**Russel Sandberg. Sun Microsystems, Inc.**

- #### Contribution
  
  - 파일 시스템에 빠르게 원격으로 접근할 수 있는 NFS(Network File System)을 구축
  - 이기종 운영체제나 아키텍처로 쉽게 이식 가능

- #### Design Goal
  
  * 시스템 및 운영체제에 독립
    
    * NFS 서버가 다양한 유형의 클라이언트에 파일을 제공할 수 있어야 하므로 사용되는 프로토콜은 UNIX와 독립적이어야 함
  
  * 충돌 복구
    
    * 클라이언트가 여러 서버에서 원격 파일 시스템을 마운트할 수 있을때 클라이언트와 서버가 시스템 충돌 및 네트워크 문제로부터 쉽게 복구될 수 있어야 함
  
  * 투명한(공개된) 접근
    
    * 프로그램이 특별한 경로명 구문 분석, 라이브러리, 재 컴파일등이 없어도 로컬 파일과 동일한 방식으로 원격 파일에 액세스할 수 있어야 함. 즉, 프로그램은 파일이 원격인지 로컬인지에 대한 여부를 알 필요가 없거나 알 수 없어야 함
  
  * UNIX 클라이언트에서 유지되는 UNIX Semantics(정책)
    
    * UNIX에서 투명한 접근이 작동하려면 원격 파일에 대한 UNIX 파일시스템 Semantics를 유지해야함
  
  * 합리적인 성능
    
    * 기존 네트워크 시스템보다 빠른 속도 구현. 작은 로컬 디스크에 접근하는것과 유사한 속도
      
      

- #### Basic Design
  
  NFS는 프로토콜, 서버, 클라이언트 세가지 부분으로 구성됨
  
  1. NFS Protocol
     
     - NFS는 Sun 원격 프로시저 호출(Remote Procedure Call, RPC) 메커니즘을 사용함
     
     - NFS는 무상태(Stateless) 프로토콜을 사용하며 서버는 과거 요청 기록과 클라이언트에 관한 어떤 내용도 저장하지 않음. 대신 클라이언트는 요청에 필요한 모든 정보를 담아서 서버에 전송(==https)
     
     - 이러한 방법은 서버의 충돌 복구 대응을 매우 쉽게 함. 충돌이 발생하면 클라이언트는 NFS 요청을 다시 보내고, 서버는 복구할 상태가 없으므로 복구를 실행하지 않음
     
     - 반면에 서버가 상태를 유지하면 복구가 훨씬 어려움. 이 상태에서는 클라이언트와 서버가 모두 서로의 충돌을 감지하고 있어야 함
       
       - 클라이언트가 충돌하면 서버는 클라이언트의 상태를 모두 버려야 하기 때문에 클라이언트의 충돌을 감지하고 있어야 함
       
       - 서버가 충돌하면 클라이언트가 서버의 상태를 재구축해야하므로 서버의 충돌을 감지하고 있어야 함
     
     - 따라서 상태 비저장 프로토콜은 복잡한 충돌 복구와 데이터 손실을 방지함. 실제로 충돌이 발생하고 원래대로 복구된 경우와, 단순히 느리게 작동하는 경우와 구분할 수 없을 정도로 프로토콜이 신속하게 작동함
     
     - 가장 기본적인 NFS 매개변수는 파일 핸들(File Handle, fh)임. == 파일 디스크립터
     
     - NFS 프로토콜에는 다양한 프로시저가 있음 (create, remove, getattr, setattr ...)
     
     - 파일 시스템의 루트 핸들은 RPC 기반의 MOUNT 프로토콜을 사용해서 클라이언트에서 얻음. 마운트 프로토콜은 디렉토리 경로 이름을 획득하고, 디렉토리를 포함한 파일 시스템에 대해 액세스 권한이 있을 경우 파일 핸들을 리턴
     
     - 마운트 프로토콜만 별도인 이유는 새로운 파일 시스템의 접근 검사를 더 쉽게 만들고, 프로토콜의 운영체제 의존성을 분리하기 위함
     
     - NFS 프로토콜과 RPC는 XDR(External Data Representation)을 기반으로 구축됨. == 독자적인 통신 형식을 정의
     
     - XDR : 표준 데이터 직렬화 형식으로 서로 다른 시스템 간 데이터 송수신을 가능하게 함. XDR는 C언어와 유사하며 프로토콜을 하드웨어나 언어와 독립적으로 만들 수 있고 쉽게 정의할 수 있게 함
2. Server Side
   
   - NFS 서버는 상태를 저장하지 않는 무상태 프로토콜을 사용하기 때문에 NFS 요청을 처리하고 결과를 반환하기 전에 수정된 데이터를 안정적인 저장소(서버사이드의 디스크)에 커밋해야 함 == 매 요청마다 파일시스템 상태를 갱신하고, 충돌하면 저장소에서 풀해서 복구하는 방식. 클라이언트 콜을 트랜잭션 단위로 처리
   
   - 그래서 쓰기 요청에서 수정된 데이터 블록뿐만 아니라 수정된 간접 블록과 inode 블록 모두 저장해야함
   
   - 또한 inode에 generation number를 추가하고 슈퍼블록(파일시스템의 메타데이터를 저장하는 블록)에 파일시스템 ID를 추가해야함. 이 추가 번호를 사용해야 서버에서 inode 번호, inode generation 번호, 파일 시스템 id를 파일 핸들로 사용할 수 있음
   
   - inode generation number는 재사용되는 inode 번호로 인한 잘못된 파일 참조를 막기 위해서 필요한데, inode가 해제되고 다른 파일을 가리키는 경우가 생길 수 있음. 따라서 파일 핸들이 서버로 돌아올 때 generation number로 inode의 변환 여부를 체크함. generation number는 inode가 해제될때마다 1씩 증가함

3. Client Side
   
   - NFS는 클라이언트 사이드의 어플리케이션에 투명한 인터페이스를 제공함
   
   - 기존의 원격 파일 액세스 방법은 /../host/path 와 같은 경로 이름을 사용해서 원격 파일의 이름을 지정했음. 이는 투명한 액세스가 아님
   
   - 따라서 파일 시스템에 마운트할 때 한번 호스트 이름을 조회하고 파일 주소를 바인딩함. 이 방법을 사용하면 클라이언트가 시스템에 마운트할 때 호스트 이름을 한번만 처리하면 되는 장점이 있지만, 마운트가 완료될때까지 클라이언트에서 원격 파일을 사용할 수 없다는 단점이 있음
   
   - NFS는 시스템에 마운트되는 다양한 유형의 파일 시스템에 투명한 접근을 두가지의 새로운 파일 시스템 인터페이스를 통해서 제공함
     
     - VFS(Virtual Filesystem) 인터페이스 :전체 파일시스템에 적용되는 프로시저를 정의함
     
     - Vnode(Virtual Node) 인터페이스 : 해당 파일 시스템 내의 개별 파일에 적용되는 프로시저를 정의함
       
       ![img](C:\Users\love9\Desktop\운영체제특론\imgs\sun1.png)
       
       
* #### Filesystem Interface
  
  * VFS 인터페이스는 파일시스템 전체에 사용할 수 있는 명령어로 구성되었고, Vnode 인터페이스는 파일시스템 내의 노드에서 사용할 수 있는 명령어로 구성됨
  
  * 커널에 마운트 된 파일 시스템 당 하나의 VFS 구조와 각 노드당 하나의 Vnode 구조가 있음. 이 추상 데이터타입을 사용하면 커널이 사용중인 기본 파일시스템 유형을 식별하지 않아도 모든 파일시스템과 노드를 동일한 방식으로 처리할 수 있음.
  
  * 각 Vnode는 상위 VFS에 대한 포인터와 마운트된 VFS에 대한 포인터를 포함함
  
  * 마운트된 VFS에 대한 포인터는 파일 시스템 트리의 모든 노드가 다른 파일 시스템의 마운트 지점(VFS)이 될 수 있음을 의미함. 따라서 VFS에는 파일시스템이 마운트된 루트 노드를 리턴하는 root 명령어가 제공됨. 루트 명령어는 기존 파일 시스템에 마운트된 파일 시스템을 연결하고, 경로 이름을 추적하는데 사용됨. 또한 마운트된 파일 시스템을 해제할 때도 사용됨
    
    

* #### Implementation
  
  1984년 3월에 NFS 구현이 시작됨
  
  * 처음으로 네트워크 파일 시스템을 포함하도록 커널을 수정하는 작업을 하였고, 6월에 첫번째 vnode 커널을 실행함. 추가된 인터페이스에 대해 오버헤드를 테스트했는데 대부분 기존과 동일한 결과를 얻었고 최악의 경우, 2% 느려짐
  
  * 새 인터페이스를 추가하는 작업은 대부분 inode를 직접 사용하거나, inode에 대한 암시적 지식(implicit knowledge)이 포함된 코드를 찾고 수정하는 작업이었음 == 간접 포인터 등
  
  * 커널의 몇가지 파일 시스템 루틴은 vnode를 사용하기 위해 완전히 다시 작성함. 경로명 조회를 수행하는 루틴인 name i는 vnode를 조회하도록 변경했고 전역 상태를 사용하지 않도록 정리됨. 새 디렉토리 항목을 추가하는 dir enter 루틴은 name i의 전역 상태에 의존하기 때문에 수정됨
  
  * 활성화된 vnode 및 VFS 수에 대한 상한선을 피하기 위해 커널에 메모리 할당자를 추가해서 이러한 구조들을 동적으로 할당, 해제할 수 있게 함. 이러한 메모리 할당자들은 커널 RPC에도 구현됨
  
  * 1984년 3월에 개발을 시작하고 나서 사용자 레벨의 RPC, XDR 라이브러리가 커널로 이식되었고, 같은 해 6월에 커널 RPC 콜을 사용할 수 있었음. 커널 RPC 콜이 왕복하는데 0.0088(8.8 밀리초)가 될때까지 약 한달동안 RPC 성능 향상을 위해 작업함
  
  * Vnode와 RPC를 구현한 후, Vnode 오퍼레이션을 NFS 원격 프로시저 호출로 변환하는 인터페이스를 구현함. 첫번째 NFS 커널은 당해 8월 중순에 실행됨. 이 시점에서 NFS 서버가 동기식 쓰기 작업을 지원하기 위해서 Vnode 인터페이스를 수정함
  
  * 마운트 프로토콜은 NFS 프로토콜에 먼저 구현되고, 이후에 사용자 레벨의 RPC 서비스로 분리함.
  
  * 서버는 마운트 요청이 들어오면 자동으로 시작됨. 마운트 데몬은 get fh 시스템콜을 사용해서 마운트되는 경로 이름을 파일 핸들로 변환해서 클라이언트에게 반환함. 클라이언트가 마운트 명령을 사용할 때, 옵션 문자열로 소프트 마운트와 하드 마운트를 선택할 수 있음
  
  * 하드 마운트는 서버가 다운되면 NFS 요청을 계속 재시도하는 반면, 소프트 마운트는 오류를 반환하고 끝냄. 소프트 마운트의 문제는 유닉스 프로그램이 시스템 콜의 반환 상태를 확인하는 행위가 효율적이지 않음. 반면에 하드 마운트된 파일 시스템은 프로세스가 잠시 중단될 뿐 데이터가 손실되지 않는다는 장점이 있음

 

* #### Filesystem Naming
  
  * 서버에 원격 파일 시스템은 두번 이상 마운트될 수 있는데, 이는 클라이언트가 같은 파일 시스템을 다른 이름으로 두번 이상 마운트할 수 있다는 것을 의미함
  
  * 따라서 저자는 머신 위에 기본 파일시스템을 올린 뒤, 여기에 사용자가 다른 파일시스템을 추가하는것을 권장함
  
  * 사용자 홈 디렉토리는 /usr/servername 에 마운트됨. 이는 /usr/1 /usr/2 등으로 사용될 수 있는데 이렇게 호스트 이름을 경로에 추가하였기 때문에 사용자가 모든 시스템에 로그인할 수 있으며 NFS 클라이언트를 시분할 터미널처럼 보이게 함
    
    

* #### Concurrent Access and File Locking
  
  * NFS는 원격 파일 잠금을 지원하지 않음. 개발 과정에서 모두가 공통적으로 찬성한 잠금 방법이 없었기 때문에 의도적으로 제외. 대신 별도의 RPC 기반 파일 잠금 기능이 있음
  
  * 파일 잠금은 본질적으로 상태 저장 기능이기 때문에 잠금 기능은 상태 모니터라는 또다른 RPC 기반 서비스에 의존함. 상태 모니터는 네트워크의 시스템 상태를 추적하여, 락 서버가 잠긴 리소스를 풀 수 있도록 함 == 근본적인 문제 해결 X
  
  * 파일 잠김 문제는 여러 클라이언트가 원격 파일에 동시에 액세스하는것과 관련됨. 로컬 파일 시스템에서 파일 수정은 inode 레벨에서 잠겨있음. 이는 두 프로세스가 같은 파일을 쓸때 데이터가 섞이는것을 방지함.
  
  * NFS 서버는 잠금을 유지하지 않고 여러 RPC 요청이 겹칠 수 있으므로 여러 클라이언트로부터 데이터가 혼합될 수 있음 -> 문제 해결 X
    
    

* #### UNIX Open File Semantics
  
  * 저자는 NFS 클라이언트가 서버나 프로토콜을 수정하지 않고 UNIX 파일시스템과 유사하게 작동하도록 구현함
  
  * 이러한 정책을 지키기 어려운 경우도 있었는데, 가령 UNIX 에서는 열려있는 파일을 제거할 수 있었음. 프로세스가 파일을 연 뒤 엔트리를 지워도 여전히 파일을 읽고 쓸 수 있음
  
  * 저자는 이를 지원하지 않을 계획이었지만 이러한 방법을 UNIX의 여러 프로그램에서 임시 파일 용도로 사용한다는것이 밝혀짐
  
  * 저자는 이 기능을 구현하기 위해 열린 파일을 삭제하는 요청이 들어오면 파일을 삭제하는 대신 이름을 바꾸도록 함. 파일 이름을 수정함으로써 클라이언트에게서 삭제된것처럼 감춘 상태로 읽기 쓰기를 지원하다가 Vnode가 비활성화되면 이를 삭제함
    
    

* #### Time Skew
  
  * 클라이언트 간, 혹은 클라이언트와 서버 간 시간 왜곡이 생겨서 파일과 연결된 시간이 일치하지 않을 수 있음
  
  * 예를 들어 ranlib 라이브러리를 원격 파일에서 실행하면 수정 시간은 서버에서 가져오고 라이브러리에 저장되는 현재 시간은 클라이언트에서 가져옴. 이러한 시간 왜곡은 시스템 시간을 파일 수정 시간과 비교하는 모든 프로그램의 잠재적인 문제임
  
  * 저자는 이후 시간 동기화 프로토콜을 사용해서 문제를 해결할 계획이라고 함
    
    

* #### Performance
  
  * NFS 개발 시간의 대부분은 성능 향상에 사용됨. 목표는 NFS의 속도를 작은 로컬 디스크와 유사하도록 하는것이었음
  
  * 속도 측정을 위해서 C 컴파일, 버블 정렬, 행렬 반전, make, 파이프라인 실행 등의 벤치마크를 사용함
  
  * 성능 향상을 위해 다음과 같은 작업을 진행함
    
    * 클라이언트와 서버 측 모두 read-ahead, write-behind 버퍼 캐시를 구현함
    
    * 파일 속성과 디렉토리 이름에 대한 클라이언트 측 캐시를 추가함
    
    * 읽기 쓰기 요청속도를 높이기 위해 UDP 패킷의 최대 크기를 2048바이트에서 9000바이트로 늘림
    
    * 커널의 mbuf(메모리 버퍼)에서 직접 XDR 변환을 수행하는 새로운 XDR 타입을 구현하여 메모리 복사 횟수를 줄임
  
  * 그 결과, 디스크가 없는 Sun-3 클라이언트와 Fujitsu Eagle disk를 사용하는 Sun-3 서버 간 통신이 로컬디스크를 사용하는 Sun-3보다 더 빨랐음
  
  * RPC 호출을 사용할때마다 read, write 오버헤드가 생기는데, 로컬에서는 전체 디렉토리의 inode가 버퍼 캐시에 있기 때문에 단순한 메모리 참조에 불과하지만 서버의 쓰기 작업은 동기식으로 작동하므로 느림
  
  * 정상적인 경우, 전체 시스템 콜에서 쓰기 명령은 5%에 해당하므로 속도 저하가 눈에 띄지 않음.
  
  * 실험 결과, row 데이터 전송 속도는 read 가 250KB/sec, write가 60KB/sec로 측정
    
    

* #### RFS vs NFS
  
  * usenix와 uniforum 컨퍼런스에서 시연됐지만 아직 출시되진 않은 AT&T RFS(Remote filesystem)은 NFS와 거의 동일한 기능을 제공함
  
  * 디자인 철학의 차이에서 약간의 차이가 생기는데, NFS는 일반 네트워크 서비스를 제공하는 반면 RFS는 분산 UNIX 파일 시스템을 제공함
  1. Networking
     
     * RFS는 UDP/IP와 같은 표준 통신 프로토콜을 사용하지 않고, 공개되지 않은 특수 목적 전송 프로토콜을 사용하는데, 이는 보편적으로 사용할 수 없음. 또한 가상 통신 회로가 머신의 충돌 시기를 결정하므로 기존 프로토콜을 대체할 수 없음
     
     * 반면, NFS는 RPC 계층을 사용해서 기본 프로토콜을 숨기므로 NFS 프로토콜을 변경하지 않고도 다른 전송 프로토콜을 쉽게 지원할 수 있음 == 추상화
     
     * RFS는 원격 프로시저 호출 메커니즘을 사용하지 않고 UNIX 시스템콜을 확장해서 원격 파일에 액세스함. 이 프로토콜은 클라이언트와 서버 양쪽에서 시스템콜을 중단할 수 있으므로 처리가 복잡해짐
  
  2. Non-Homogeneous Machines and Operating Systems
     
     * NFS는 16개 회사의 하드웨어에서 작동하고, berkeley, sun os, dec ultrix, ms/dos 등 다양한 운영체제에서 실행되지만, RFS는 System V.3 이외의 운영체제를 지원하지 않음
  
  3. Crash Recovery
     
     * RFS는 상태 저장 프로토콜을 사용함. 서버는 진행중인 모든 클라이언트의 요청 상태와 마운트 지점, 열린 파일, 디렉토리와 장치 정보를 모두 유지 관리함
     
     * 서버 충돌 후 클라이언트가 서버 상태를 재구축하는것은 어렵고 비용이 크기 때문에 RFS는 서버 충돌 복구를 시행하지 않으며, 이는 로컬 디스크를 잃는 것과 같음
     
     * 또한 일반적으로 네트워크 지연, 중단, 과부하는 시스템 충돌과 구분할 수 없으므로 비용이 더 커짐
  
  4. UNIX Semantics
     
     * NFS는 UNIX 파일 시스템의 모든 정책을 적용하진 않는 반면, RFS는 모든 정책을 적용함
     
     * 그러나 서버가 충돌했을 때, 일반적으로 클라이언트 응용 프로그램은 디스크 오류를 발생시키는데 이는 매우 심각한 오류 상태이므로 응용 프로그램이 복구를 시도하지 않음 == UNIX 정책이 의미가 없음
  
  5. Conclusion
     
     * System V.3에서 실행하는 소규모 네트워크 시스템에서는 RFS는 좋은 선택이고,
       대규모 네트워크, 프로토콜이나 머신 유형, 운영체제가 혼합된 네트워크는 NFS가 더 좋은 선택임
     
     * 두 파일 시스템은 상호 배타적이지 않고, 함께 사용할 수 있음
